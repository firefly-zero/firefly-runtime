use crate::error::HostError;
use crate::net::{ConnectStatus, Intro};
use crate::state::{NetHandler, State};
use alloc::boxed::Box;
use firefly_hal::Device;

type C<'a, 'b> = wasmi::Caller<'a, Box<State<'b>>>;

/// Write a debug log message into console.
pub(crate) fn log_debug(mut caller: C, ptr: u32, len: u32) {
    let state = caller.data_mut();
    state.called = "misc.log_debug";
    let Some(memory) = state.memory else {
        state.log_error(HostError::MemoryNotFound);
        return;
    };
    let (data, state) = memory.data_and_store_mut(&mut caller);
    let ptr = ptr as usize;
    let len = len as usize;
    let Some(bytes) = &data.get(ptr..(ptr + len)) else {
        state.log_error(HostError::OomPointer);
        return;
    };
    let Ok(text) = core::str::from_utf8(bytes) else {
        state.log_error(HostError::TextUtf8);
        return;
    };
    state.device.log_debug("app", text);
}

/// Write a error log message into console.
pub(crate) fn log_error(mut caller: C, ptr: u32, len: u32) {
    let state = caller.data_mut();
    state.called = "misc.log_error";
    let Some(memory) = state.memory else {
        state.log_error(HostError::MemoryNotFound);
        return;
    };
    let (data, state) = memory.data_and_store_mut(&mut caller);
    let ptr = ptr as usize;
    let len = len as usize;
    let Some(bytes) = &data.get(ptr..(ptr + len)) else {
        state.log_error(HostError::OomPointer);
        return;
    };
    let Ok(text) = core::str::from_utf8(bytes) else {
        state.log_error(HostError::TextUtf8);
        return;
    };
    state.device.log_error("app", text);
}

/// Set random numbers generator seed.
pub(crate) fn set_seed(mut caller: C, seed: u32) {
    let state = caller.data_mut();
    state.called = "misc.set_seed";
    state.seed = seed;
    state.lock_seed = true;
}

/// Get a pseudo-random integer.
///
/// Uses [xorshift] algorithm. It's very fast, easy to implement,
/// and has a very long period. Wikipedia claims that it fails some
/// statistical tests, but that still should be good enough for games.
///
/// [xorshift]: https://en.wikipedia.org/wiki/Xorshift
pub(crate) fn get_random(mut caller: C) -> u32 {
    let state = caller.data_mut();
    state.called = "misc.get_random";

    // Use true RNG if no seed set by the app and it's not a multiplayer.
    let handler = state.net_handler.get_mut();
    if !state.lock_seed && matches!(handler, NetHandler::None) {
        return state.device.random();
    }

    let mut x = state.seed;
    if x == 0 {
        x = 1;
    }
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    state.seed = x;
    x
}

/// Get the name of the given peer device.
///
/// The buffer must be at least 16 bytes. Returns how many bytes are written.
///
/// The name should be valid and generated by firefly-cli when bootstrapping the FS.
/// If the name is missed or invalid, the buffer is untouched and 0 is returned.
pub(crate) fn get_name(mut caller: C, index: u32, ptr: u32) -> u32 {
    let state = caller.data_mut();
    state.called = "misc.get_name";
    let Some(memory) = state.memory else {
        state.log_error(HostError::MemoryNotFound);
        return 0;
    };
    let (data, state) = memory.data_and_store_mut(&mut caller);

    let handler = state.net_handler.get_mut();
    let name: &str = match handler {
        NetHandler::FrameSyncer(syncer) => {
            let Some(peer) = syncer.peers.get(index as usize) else {
                state.log_error("invalid peer ID");
                return 0;
            };
            &peer.intro.name
        }
        NetHandler::None => &state.settings.name,
        NetHandler::Connector(connector) => {
            if index == 0 {
                &connector.me.name
            } else {
                let index = index as usize - 1;
                match connector.peer_infos().get(index) {
                    Some(peer) => &peer.intro.name,
                    None => {
                        let peers = connector.peer_addrs().len();
                        if index > peers {
                            return 0;
                        }
                        "???"
                    }
                }
            }
        }
        NetHandler::Connection(connection) => {
            let Some(peer) = connection.peers.get(index as usize) else {
                return 0;
            };
            &peer.intro.name
        }
    };

    if name.is_empty() {
        return 0;
    }
    let ptr = ptr as usize;
    let len = name.len().min(16);
    let Some(buf) = data.get_mut(ptr..(ptr + len)) else {
        state.log_error(HostError::OomPointer);
        return 0;
    };
    buf.copy_from_slice(name.as_bytes());
    name.len() as u32
}

/// Get packed (some) system settings of the peer.
///
/// Contains interface language, color theme, and some boolean flags.
pub(crate) fn get_settings(mut caller: C, index: u32) -> u64 {
    let state = caller.data_mut();
    state.called = "misc.get_settings";

    let handler = state.net_handler.get_mut();
    match handler {
        NetHandler::FrameSyncer(syncer) => {
            let Some(peer) = syncer.peers.get(index as usize) else {
                state.log_error("invalid peer ID");
                return 0;
            };
            pack_intro(&peer.intro)
        }
        NetHandler::None => {
            let s = &state.settings;
            let flags = u8::from(s.rotate_screen)
                | u8::from(s.reduce_flashing) << 1
                | u8::from(s.contrast) << 2
                | u8::from(s.easter_eggs) << 3;
            pack_settings(s.theme, flags, s.lang)
        }
        NetHandler::Connector(connector) => {
            if index == 0 {
                pack_intro(&connector.me)
            } else {
                let index = index as usize - 1;
                match connector.peer_infos().get(index) {
                    Some(peer) => pack_intro(&peer.intro),
                    None => 0,
                }
            }
        }
        NetHandler::Connection(connection) => {
            let Some(peer) = connection.peers.get(index as usize) else {
                return 0;
            };
            pack_intro(&peer.intro)
        }
    }
}

#[inline]
fn pack_intro(intro: &Intro) -> u64 {
    pack_settings(intro.theme, intro.flags, intro.lang)
}

fn pack_settings(theme: u32, flags: u8, lang: [u8; 2]) -> u64 {
    let lang = u64::from(lang[0]) << 8 | u64::from(lang[1]);
    let flags = u64::from(flags);
    let theme = u64::from(theme);
    theme << 32 | flags << 16 | lang
}

/// Stop the currently running app and run the default launcher instead.
pub(crate) fn quit(mut caller: C) {
    let state = caller.data_mut();
    state.called = "misc.quit";
    let state = caller.data_mut();
    state.set_next(None);
}

/// Stop the currently running app and start it again.
pub(crate) fn restart(mut caller: C) {
    let state = caller.data_mut();
    state.called = "misc.restart";
    let state = caller.data_mut();
    state.set_next(Some(state.id.clone()));
}

/// Undocumented function used by the connector app.
pub(crate) fn set_conn_status(mut caller: C, val: u32) {
    let state = caller.data_mut();
    state.called = "misc.restart";
    let state = caller.data_mut();
    let status = match val {
        1 => ConnectStatus::Stopped,
        2 => ConnectStatus::Cancelled,
        3 => ConnectStatus::Finished,
        _ => {
            state.log_error("invalid connection status");
            return;
        }
    };
    let NetHandler::Connector(connector) = state.net_handler.get_mut() else {
        state.log_error("can set connection status only for connector");
        return;
    };
    connector.status = Some(status);
}
