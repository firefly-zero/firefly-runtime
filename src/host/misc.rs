use crate::error::HostError;
use crate::state::{NetHandler, State};
use firefly_hal::Device;

type C<'a, 'b> = wasmi::Caller<'a, State<'b>>;

/// Write a debug log message into console.
pub(crate) fn log_debug(mut caller: C, ptr: u32, len: u32) {
    let state = caller.data_mut();
    state.called = "misc.log_debug";
    let Some(memory) = state.memory else {
        state.log_error(HostError::MemoryNotFound);
        return;
    };
    let (data, state) = memory.data_and_store_mut(&mut caller);
    let ptr = ptr as usize;
    let len = len as usize;
    let Some(bytes) = &data.get(ptr..(ptr + len)) else {
        state.log_error(HostError::OomPointer);
        return;
    };
    let Ok(text) = core::str::from_utf8(bytes) else {
        state.log_error(HostError::TextUtf8);
        return;
    };
    state.device.log_debug("app", text);
}

/// Write a error log message into console.
pub(crate) fn log_error(mut caller: C, ptr: u32, len: u32) {
    let state = caller.data_mut();
    state.called = "misc.log_error";
    let Some(memory) = state.memory else {
        state.log_error(HostError::MemoryNotFound);
        return;
    };
    let (data, state) = memory.data_and_store_mut(&mut caller);
    let ptr = ptr as usize;
    let len = len as usize;
    let Some(bytes) = &data.get(ptr..(ptr + len)) else {
        state.log_error(HostError::OomPointer);
        return;
    };
    let Ok(text) = core::str::from_utf8(bytes) else {
        state.log_error(HostError::TextUtf8);
        return;
    };
    state.device.log_error("app", text);
}

/// Set random numbers generator seed.
pub(crate) fn set_seed(mut caller: C, seed: u32) {
    let state = caller.data_mut();
    state.called = "misc.set_seed";
    state.seed = seed;
}

/// Get a pseudo-random integer.
///
/// Uses [xorshift] algorithm. It's very fast, easy to implement,
/// and has a very long period. Wikipedia claims that it fails some
/// statistical tests, but that still should be good enough for games.
///
/// [xorshift]: https://en.wikipedia.org/wiki/Xorshift
pub(crate) fn get_random(mut caller: C) -> u32 {
    let state = caller.data_mut();
    state.called = "misc.get_random";
    let mut x = state.seed;
    if x == 0 {
        x = 1;
    }
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    state.seed = x;
    x
}

/// Get the name of the given peer device.
///
/// The buffer must be at least 16 bytes. Returns how many bytes are written.
///
/// The name should be valid and generated by firefly-cli when bootstrapping the FS.
/// If the name is missed or invalid, the buffer is untouched and 0 is returned.
pub(crate) fn get_name(mut caller: C, index: u32, ptr: u32) -> u32 {
    let state = caller.data_mut();
    state.called = "misc.get_name";
    let Some(memory) = state.memory else {
        state.log_error(HostError::MemoryNotFound);
        return 0;
    };
    let (data, state) = memory.data_and_store_mut(&mut caller);
    let name: &str = if is_online(state) {
        let handler = state.net_handler.get_mut();
        let NetHandler::FrameSyncer(syncer) = handler else {
            // It could've been type safe with pattern matching but then
            // the borrow checker is unhappy.
            unreachable!("must be called only if is_online check returns true");
        };
        let Some(peer) = syncer.peers.get(index as usize) else {
            return 0;
        };
        &peer.name
    } else {
        &state.get_settings().name
    };
    if name.is_empty() {
        return 0;
    }
    let ptr = ptr as usize;
    let len = name.len().min(16);
    let Some(buf) = data.get_mut(ptr..(ptr + len)) else {
        state.log_error(HostError::OomPointer);
        return 0;
    };
    buf.copy_from_slice(name.as_bytes());
    name.len() as u32
}

/// Check if there is a frame syncer available.
fn is_online(state: &mut State) -> bool {
    let handler = state.net_handler.get_mut();
    matches!(handler, NetHandler::FrameSyncer(_))
}

/// Stop the currently running app and run the default launcher instead.
pub(crate) fn quit(mut caller: C) {
    let state = caller.data_mut();
    state.called = "misc.quit";
    let state = caller.data_mut();
    state.exit = true;
}

/// Stop the currently running app and start it again.
pub(crate) fn restart(mut caller: C) {
    let state = caller.data_mut();
    state.called = "misc.restart";
    let state = caller.data_mut();
    state.set_next(state.id.clone());
}
