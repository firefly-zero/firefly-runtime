use super::NetcodeError;
use crate::config::FullID;
use alloc::boxed::Box;
use firefly_hal::InputState;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
pub(crate) enum Message {
    Req(Req),
    Resp(Resp),
}

impl From<Resp> for Message {
    fn from(v: Resp) -> Self {
        Self::Resp(v)
    }
}

impl From<Req> for Message {
    fn from(v: Req) -> Self {
        Self::Req(v)
    }
}

impl Message {
    // TODO: return NetworkError
    pub fn decode(s: &[u8]) -> Result<Self, NetcodeError> {
        if s.is_empty() {
            return Err(NetcodeError::EmptyBufferIn);
        }
        if s == b"HELLO" {
            return Ok(Self::Req(Req::Hello));
        }
        let res = postcard::from_bytes(s);
        match res {
            Ok(raw) => Ok(raw),
            Err(err) => Err(NetcodeError::Deserialize(err)),
        }
    }

    pub fn encode<'a>(&self, buf: &'a mut [u8]) -> Result<&'a mut [u8], NetcodeError> {
        let res = postcard::to_slice(self, buf);
        match res {
            Ok(raw) => {
                if raw.is_empty() {
                    Err(NetcodeError::EmptyBufferOut)
                } else {
                    Ok(raw)
                }
            }
            Err(err) => Err(NetcodeError::Serialize(err)),
        }
    }
}

/// A network request: a message that the device sends unprompted.
#[derive(Serialize, Deserialize)]
pub(crate) enum Req {
    Hello,
    /// Ask the device to re-send their intro.
    Intro,
    /// Ask the device if it is already started an app.
    Start,
    /// Request the state for the given frame.
    State(u32),
    /// Tell other devices that this device is going to disconnect.
    Disconnect,
}

/// A response to a request from another device.
#[derive(Serialize, Deserialize)]
pub(crate) enum Resp {
    Intro(Intro),
    /// Launch an app.
    Start(Start),
    /// The app state sync, sent every frame when running an app.
    State(FrameState),
    /// Tell other devices that this device's user has accepted the peers' list.
    ///
    /// Inlcudes the number of peers.
    Ready(u8),
}

#[derive(Serialize, Deserialize)]
pub(crate) struct Intro {
    pub name: heapless::String<16>,
    pub version: u16,
}

// TODO: drop Copy.
#[derive(Copy, Clone, Serialize, Deserialize)]
pub(crate) struct FrameState {
    pub frame: u32,
    pub input: Input,
    /// The true RNG seed generated by the peer (or zero).
    pub rand: u32,
    // rand_key: Option<...>
    /// A system action that all devices should do instead of rendering the frame.
    pub action: Action,
}

#[derive(Copy, Clone, PartialEq, Serialize, Deserialize)]
pub(crate) enum Action {
    /// No action.
    None,
    /// Restart the currently running app.
    Restart,
    /// Exit the currently running app.
    Exit,
}

#[derive(Clone, Serialize, Deserialize)]
pub(crate) struct Start {
    /// The full ID of the app to run.
    pub id: FullID,
    /// The peer's progress for each badge.
    pub badges: Box<[u16]>,
    /// The peer's top score for each board.
    pub scores: Box<[i16]>,
    /// The peer's stash, shared state preserved across games.
    pub stash: Box<[u8]>,
    /// The random seed to be used at the app startup.
    pub seed: u32,
}

#[derive(Copy, Clone, Serialize, Deserialize)]
pub(crate) struct Input {
    pub pad: Option<(i16, i16)>,
    pub buttons: u8,
}

impl From<Input> for InputState {
    fn from(value: Input) -> Self {
        Self {
            pad: value.pad.map(Into::into),
            buttons: value.buttons,
        }
    }
}
